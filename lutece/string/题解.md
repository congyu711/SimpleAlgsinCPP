# n
我直接爆搜
使用的剪枝有：
1. 把a数组排序，从小到大取
2. 维护一下前缀和，如果发现搜到的结果加上以后的最大结果还是比当前答案小就不搜了
3. 如果当前比t大，当然不搜了
4. 如果搜到了t，就不用在搜了，答案不可能更优了
然后就卡过了
看了题解发现应该二分。
n=40，分成前后两个区间，每个区间的组合数量也就2^20(1e6)左右，可以全部存下来，然后给右边区间的所有结果排序，枚举左边区间的结果，然后二分查找最大的能用的右边区间的结果，加起来就是一个答案。然后答案取max即可。

# o
给n个数(n<=25)，在这n个数中最多可以选择k个数让他们变成自己的阶乘，然后在整个数组中选择一些数，让他们的和为s，问方案数。
对于每一个数有三种可能：
1. 选，不变阶乘
2. 选，变阶乘
3. 不选

这样搜索所有情况应该有$3^25$，有点大，想到要折半搜索。

# q
kmp
暴力的字符串匹配，txt字符串现在从第i为开始和pat串比较，发生失配，i变成i+1。慢在失配的时候从txt的i+1和pat重新比较。
发现如果pat串在某个位置失配了，前面的一定都匹配上了，考虑pat已经匹配的这一部分，如果他后面一部分和开头是一样的，那么这一部分就不需要在比较了。
比如```pat: abxxxxxabxxxx```这里如果到第二个b后面失配了，至少这个ab是可以重复利用的。于是发现就是要找出pat串每个位置的前缀函数是多少。如果前缀函数是```p[i]```，那么如果第i位发生失配了(此时txt比较到了第k位)，直接比较```pat[p[i-1]]```和 ```txt[k]```就行了。如果前缀函数是0或者第i位匹配上了，才把k+1；
简单看看匹配的时候的复杂度。下面txt长度是```n```,pat长度是```m```。匹配的时候要比较```n+失配次数```次。可以想到一个最坏情况
```
pat:aaaaa
txt:aaaabaaaabaaaab
```
这样一来失配次数就是$\frac{n}{m}*m$次，也是$O(n)$的，因此匹配过程就是$O(n)$的。
然后问题在于如何求前缀函数。
这可以递推计算。
1. 如果```s[i]==s[p[i-1]]```那么```p[i]=p[i-1]+1```
2. 如果```s[i]!=s[p[i-1]]```，这时实际上相当于这个字符串的一个后缀和一个前缀进行字符串匹配，然后最后一位失配了。用和上面类似的思想，就要找这个前缀的最后一位的前缀函数对应的字符来和第i位的字符比较。
很容易写出求前缀函数的过程。
```cpp
for(int i=1;i<pat.length();i++)
{
    int k=pi[i-1];
    while(k>0&&pat[i]!=pat[k])  k=pi[k-1];
    if(pat[k]==pat[i])  k++;
    pi[i]=k;
    if(pi[i]==n)    ans++;
}
```