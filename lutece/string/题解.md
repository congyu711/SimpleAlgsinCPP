# h
ac自动机
要求出很多pat串在txt串中出现的次数（位置）；
这和kmp很像，只不过pat串现在有多个。那用相似的思路，先预处理出一个能包含所有pat的前缀函数，然后开始匹配，失配的时候去找前缀函数对应的值继续比较。
由于有很多pat，pat[i]失配的时候可能需要跳到pat[j]，这就导致这个前缀函数变成了一个有向图。

首先把pat串都存在一个trie里面，然后开始计算这个前缀函数(构建fail指针)；
类似kmp的思路，现在trie里面有个节点u，他通过一条写着```a```的边指向v，那么v这个地方的失配指针就应该指向u的失配指针指向的节点走写着```a```的边到达的节点。然而这个节点很可能不存在，那就需要去找u的失配指针指向的点的失配指针指向的点，看这个点有没有写着```a```的边到达的节点，如果没有接着重复这个过程，直到找到或者到达根节点为止。
上面这个过程肯定是越跳深度越小的，而且要求上面的fail指针都算出来了，那就需要从trie的根节点开始bfs。

这里看oiwiki得知了一个优化，如果像上面说的循环跳fail来构建u的fail指针的话可能需要跳很多次。现在想要只跳一次，直接跳到循环最后那个节点。如果第一次跳fail成功了当然就结束了，但是如果发现那个节点不存在就要跳很多次，所以我们就把这个节点补上。如果发现trie上节点u的某个边没有节点了，就把这条边建出来，连上一个节点v，如果匹配的时候走到节点u，然后走了刚刚建的这个边，这就应该失配，因为这个边本来是根本不存在的，于是就让刚刚建的这个边指向v的fail指针指向的节点，也就是说让v等于这个位置的fail指针应该指向的节点。

这样一来就有神奇的效果，因为是bfs建的fail指针，深度小的肯定先建好，要找一个节点的fail指针不可能遇到要跳超过一次的情况，u的失配指针的节点的那个出边连接的节点肯定存在。这样一来在建fail指针的时候就不会跳很多次了。
这东西好像没什么用，只能在建fail指针的时候少写几行代码，复杂度也不是卡在建fail指针，根本没影响。。。

现在开始匹配了，首先可能有一样的pat串，那就开一个vector，记录一下trie上面节点u处结束的pat串编号都是什么，然后匹配的时候就直接跑，然后如果遇到一个点失配了，就一直跳fail链，直到跳到根节点了，跳到的节点如果是pat的结尾的话就记录一下答案。发现这么做tle了，但是很容易发现每次跳fail链其实浪费时间，应该记录下来每个节点被匹配了几次，最后一起放到fail链组成的树上统计答案。
我首先把fail链建好了，然后开始在trie上找txt，到节点u的时候就把```cnt[u]++```，表示走到这里的时候要多跳一遍fail链，但是我现在先不跳。然后把fail[u]->u的图建出来，然后dfs统计答案就行了。

# l
给定一个字符矩阵，问有多少子矩阵满足这个条件：任意行的字母在行内任意重新排列，子矩阵的任意行和列都是回文串。
字符矩阵长宽```n，m<=250```

因为每行可以随便重新排列，所以每行是否是回文串就只需要考虑每种字符出现的次数，即至多只能有一种字符出现的次数是奇数。现在有一个子矩阵，首先按前面说的判断行是否能为回文串，如果不行那这个子矩阵直接失败，如果可以再看列能不能是回文串。
那就有了一个做法，枚举子矩阵的左右边界，然后判断每一行是否能形成回文串，有可能有一些行形不成回文串，我把连续的能形成回文串的行都拿出来，把行当成元素纵向跑manacher算回文串长度，答案就应该增加所有跑出来的回文串长度。枚举所有边界需要$n^2$的时间，然后跑manacher也需要n的时间，这就是$O(n^3)$的做法，n=250，还是可以过的。
manacher：现在先求以某个字符为中心的回文串的长度。暴力是$O(n^2)$的，需要以每个字符为中心暴力找，然而现在有一个长回文串，他左面和右面有短回文串，分为以下三种情况：
1. 左侧的小回文串完全在大回文串内部，右边对称的小回文串也不会超过大回文串右边界；
2. 左侧的小回文串刚好从大回文串左端点开始，右边的小回文串可能会超过大回文串的右边界；
3. 左侧的小回文串超过了大回文串左端点，右边的小回文串肯定不可能超过大回文串右端点，这是因为如果对称的小回文串还能继续延申的话，就意味着大回文串右侧一个字符和左侧一个字符相同，这个大回文串就可以延申了；

一共只有上面三种情况，可以看到如果找到一个长回文串，只有第二种情况小回文串才可能延申，1，3实际上根本不用管，直接把对称的小回文串长度操作一下（避免超过大回文串的边界）抄过来就行了，遇到第二种情况的时候不过是暴力找一下回文串。

# n
我直接爆搜
使用的剪枝有：
1. 把a数组排序，从小到大取
2. 维护一下前缀和，如果发现搜到的结果加上以后的最大结果还是比当前答案小就不搜了
3. 如果当前比t大，当然不搜了
4. 如果搜到了t，就不用在搜了，答案不可能更优了

然后就卡过了
看了题解发现应该二分。
n=40，分成前后两个区间，每个区间的组合数量也就2^20(1e6)左右，可以全部存下来，然后给右边区间的所有结果排序，枚举左边区间的结果，然后二分查找最大的能用的右边区间的结果，加起来就是一个答案。然后答案取max即可。

# o
给n个数(n<=25)，在这n个数中最多可以选择k个数让他们变成自己的阶乘，然后在整个数组中选择一些数，让他们的和为s，问方案数。
对于每一个数有三种可能：
1. 选，不变阶乘
2. 选，变阶乘
3. 不选

这样搜索所有情况应该有$3^{25}$，有点大，想到要折半搜索。
把a数组分成前后两部分，每部分的状态数有$3^13$，那我就把他全部存下来。然后像n题一样合并统计答案，问题就在于怎么存状态。
首先要求变成阶乘的数字不能超过k个。那么要记录使用的阶乘数量和组合成的答案数量。于是就想到给前后两半数组都开长度为26的map数组。```vector<map<LL,LL>> mp(26)```，然后```mp[i][j]```表示把i个数字变成阶乘，组合成了和为j的数字，一共有多少种方案。于是就可以枚举左边的每一种方案，在右边的map里面找一下有没有满足使用的阶乘的数量和小于等于k的和为s的方案。然后把左右方案数的乘积加到答案里即可。（为了方面枚举我还在左边写了set数组来找map里面那些需要枚举）
RE了一次，发现没有判断阶乘数组越界。19的阶乘就超过s的最大值了。

# q
kmp
暴力的字符串匹配，txt字符串现在从第i为开始和pat串比较，发生失配，i变成i+1。慢在失配的时候从txt的i+1和pat重新比较。
发现如果pat串在某个位置失配了，前面的一定都匹配上了，考虑pat已经匹配的这一部分，如果他后面一部分和开头是一样的，那么这一部分就不需要在比较了。
比如```pat: abxxxxxabxxxx```这里如果到第二个b后面失配了，至少这个ab是可以重复利用的。于是发现就是要找出pat串每个位置的前缀函数是多少。如果前缀函数是```p[i]```，那么如果第i位发生失配了(此时txt比较到了第k位)，直接比较```pat[p[i-1]]```和 ```txt[k]```就行了。如果前缀函数是0或者第i位匹配上了，才把k+1；
简单看看匹配的时候的复杂度。下面txt长度是```n```,pat长度是```m```。匹配的时候要比较```n+失配次数```次。可以想到一个最坏情况
```
pat:aaaaa
txt:aaaabaaaabaaaab
```
这样一来失配次数就是$\frac{n}{m}*m$次，也是$O(n)$的，因此匹配过程就是$O(n)$的。
然后问题在于如何求前缀函数。
这可以递推计算。
1. 如果```s[i]==s[p[i-1]]```那么```p[i]=p[i-1]+1```
2. 如果```s[i]!=s[p[i-1]]```，这时实际上相当于这个字符串的一个后缀和一个前缀进行字符串匹配，然后最后一位失配了。用和上面类似的思想，就要找这个前缀的最后一位的前缀函数对应的字符来和第i位的字符比较。
很容易写出求前缀函数的过程。
```cpp
for(int i=1;i<pat.length();i++)
{
    int k=pi[i-1];
    while(k>0&&pat[i]!=pat[k])  k=pi[k-1];
    if(pat[k]==pat[i])  k++;
    pi[i]=k;
    if(pi[i]==n)    ans++;
}
```

# w
迭代加深搜索。
首先稍微计算一下，如果用dfs，不一定能找到最优解，如果用bfs，每个状态节点最多7个儿子，一共15层，还有10组数据，显然跑不出来。需要结合一下bfs和dfs的优点。选择迭代加深搜索。limit从1开始增加到15，对于每个limit都跑一次dfs，但是深度不要超过limit，这样不会爆空间，而且还能保证最优解，还能利用层数信息剪枝。
显然应该从空格开始搜，然后枚举空格能去到的七个方向继续dfs。然后发现如果要跳马必然要跳到空格，也就是说每一步都看成是空格在跳，跳n步最多可以更改n+1个位置，于是可以用```limit-dep```和```diff```比较确定有没有继续搜索的必要。（wa了很多次也是因为这个，如果判断```if(diff>(limit-dep)+1)```为真，说明不用继续搜索了，应该立即回溯到父节点，但是我写成了直接return，把父节点的其他儿子也给跳过去了。）
然后不要每次都比较整个棋盘是否和要求的局面一致。可以预先比较一次，计算出有多少不一样，然后每次跳空格的时候更改不一致的棋子的个数。
