# n
我直接爆搜
使用的剪枝有：
1. 把a数组排序，从小到大取
2. 维护一下前缀和，如果发现搜到的结果加上以后的最大结果还是比当前答案小就不搜了
3. 如果当前比t大，当然不搜了
4. 如果搜到了t，就不用在搜了，答案不可能更优了
然后就卡过了
看了题解发现应该二分。
n=40，分成前后两个区间，每个区间的组合数量也就2^20(1e6)左右，可以全部存下来，然后给右边区间的所有结果排序，枚举左边区间的结果，然后二分查找最大的能用的右边区间的结果，加起来就是一个答案。然后答案取max即可。

# o
给n个数(n<=25)，在这n个数中最多可以选择k个数让他们变成自己的阶乘，然后在整个数组中选择一些数，让他们的和为s，问方案数。
对于每一个数有三种可能：
1. 选，不变阶乘
2. 选，变阶乘
3. 不选

这样搜索所有情况应该有$3^25$，有点大，想到要折半搜索。
把a数组分成前后两部分，每部分的状态数有$3^13$，那我就把他全部存下来。然后像n题一样合并统计答案，问题就在于怎么存状态。
首先要求变成阶乘的数字不能超过k个。那么要记录使用的阶乘数量和组合成的答案数量。于是就想到给前后两半数组都开长度为26的map数组。```vector<map<LL,LL>> mp(26)```，然后```mp[i][j]```表示把i个数字变成阶乘，组合成了和为j的数字，一共有多少种方案。于是就可以枚举左边的每一种方案，在右边的map里面找一下有没有满足使用的阶乘的数量和小于等于k的和为s的方案。然后把左右方案数的乘积加到答案里即可。（为了方面枚举我还在左边写了set数组来找map里面那些需要枚举）
RE了一次，发现没有判断阶乘数组越界。19的阶乘就超过s的最大值了。

# q
kmp
暴力的字符串匹配，txt字符串现在从第i为开始和pat串比较，发生失配，i变成i+1。慢在失配的时候从txt的i+1和pat重新比较。
发现如果pat串在某个位置失配了，前面的一定都匹配上了，考虑pat已经匹配的这一部分，如果他后面一部分和开头是一样的，那么这一部分就不需要在比较了。
比如```pat: abxxxxxabxxxx```这里如果到第二个b后面失配了，至少这个ab是可以重复利用的。于是发现就是要找出pat串每个位置的前缀函数是多少。如果前缀函数是```p[i]```，那么如果第i位发生失配了(此时txt比较到了第k位)，直接比较```pat[p[i-1]]```和 ```txt[k]```就行了。如果前缀函数是0或者第i位匹配上了，才把k+1；
简单看看匹配的时候的复杂度。下面txt长度是```n```,pat长度是```m```。匹配的时候要比较```n+失配次数```次。可以想到一个最坏情况
```
pat:aaaaa
txt:aaaabaaaabaaaab
```
这样一来失配次数就是$\frac{n}{m}*m$次，也是$O(n)$的，因此匹配过程就是$O(n)$的。
然后问题在于如何求前缀函数。
这可以递推计算。
1. 如果```s[i]==s[p[i-1]]```那么```p[i]=p[i-1]+1```
2. 如果```s[i]!=s[p[i-1]]```，这时实际上相当于这个字符串的一个后缀和一个前缀进行字符串匹配，然后最后一位失配了。用和上面类似的思想，就要找这个前缀的最后一位的前缀函数对应的字符来和第i位的字符比较。
很容易写出求前缀函数的过程。
```cpp
for(int i=1;i<pat.length();i++)
{
    int k=pi[i-1];
    while(k>0&&pat[i]!=pat[k])  k=pi[k-1];
    if(pat[k]==pat[i])  k++;
    pi[i]=k;
    if(pi[i]==n)    ans++;
}
```

# w
迭代加深搜索。
首先稍微计算一下，如果用dfs，不一定能找到最优解，如果用bfs，每个状态节点最多7个儿子，一共15层，还有10组数据，显然跑不出来。需要结合一下bfs和dfs的优点。选择迭代加深搜索。limit从1开始增加到15，对于每个limit都跑一次dfs，但是深度不要超过limit，这样不会爆空间，而且还能保证最优解，还能利用层数信息剪枝。
显然应该从空格开始搜，然后枚举空格能去到的七个方向继续dfs。然后发现如果要跳马必然要跳到空格，也就是说每一步都看成是空格在跳，跳n步最多可以更改n+1个位置，于是可以用```limit-dep```和```diff```比较确定有没有继续搜索的必要。（wa了很多次也是因为这个，如果判断```if(diff>(limit-dep)+1)```为真，说明不用继续搜索了，应该立即回溯到父节点，但是我写成了直接return，把父节点的其他儿子也给跳过去了。）
然后不要每次都比较整个棋盘是否和要求的局面一致。可以预先比较一次，计算出有多少不一样，然后每次跳空格的时候更改不一致的棋子的个数。
