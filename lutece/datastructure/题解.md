# a
方便起见，令区间出现次数严格大于区间长度一半向上取整的元素叫高频元素
首先推公式，只要不存在高频元素，答案始终为1，如果有高频元素且出现次数为x，首先将区间长度len-x个元素匹配上len-x+1个高频元素，然后剩余x-len+x-1个元素，每次只能取一个，因此答案为1+2x-len+1，即为2x-(r-l+1);

因此答案就是max(1,2x-(r-l+1))
这道题变为求给定区间的x

如果有高频元素，那么区间第len/2大必然等于高频元素，想到使用主席树来求区间第k大，然后判断一下这个元素有多少个即可。
求固定区间第k大，我们只需要建立权值线段树就行了，但是要找给定的任意区间第k大，我们需要对于1-n每一个数都建立一颗包含1-x的权值线段树，然后区间l，r的数的个数就是1-r区间对应的线段树对应的个数-1-(l-1)的区间对应的线段树的数的个数，但是我们每次建树会mle，但是发现新建一个线段树比前一个线段树只有logn个点不同，因此我们重复使用前面的线段树，这就是主席树了。
我们在这个建好的主席树上查找，如果某个元素在区间l，r出现次数大于len/2就成功找到了高频元素，不然就在大小大于len/2的子树中找。如果没有找到就说明无高频元素。
建树时空复杂度都是nlogn，单词询问的时间复杂度是logn

# d
发现这个题需要删除序列中一个元素，插入到另一个位置，还需要反转序列，显然是使用链表，O1插入删除
需要注意的是实际上不需要真正反转序列，用一个变量记录反转的状态，如果反转了1和2操作就互相交换了，每次反转就对记录反转状态的bool变量取反.

# e
序列最小值最大，显然是二分答案。
如果能度过x个寒潮，小于x个寒潮肯定都可以度过，满足答案的有序性。
问题变成了如何判断答案为ans的时候是否可行。
我们发现啊，他有个区间+k的操作，而且判断的是单个元素的最小值能否大于等于ans，就想到可以用差分来处理这个区间加法然后再求前缀和。现在问题变成了如何使用这m堆篝火。
假设我们从arr[0]开始处理，处理到了arr[i]，发现arr[i]是小于ans的，我们必须给arr[i]插入一个篝火。如果这个篝火左侧超过了i，这说明篝火的左侧浪费了，因为左边所有元素已经大于等于ans了，不需要再插入，因此我们贪心的让篝火的左端点就在i。
因此我们每次判断答案的时候对序列做差分，然后做上面说的贪心，并且维护一个sum来当作1-i的前缀和，用sum判断arr[i]是否大于ans。
二分答案logn，判断On，这样时间复杂度nlogn

# f
区间均匀随机。就是说每个区间出现概率都一样，因此我们只需要求出每个区间的最大值和最小值的和就可以轻松算出答案。
问题变成了如何求区间最大值和最小值的和。
先看最大值。先看一个元素arr[i]，这个元素对于最终答案的贡献就是他作为最大值的区间个数乘以它本身。那我们需要维护他前面第一个比他大的元素和他后面第一个比他大的元素。这显然是使用单调栈维护。我们用单调栈维护四个东西。前面/后面的第一个大于/小于arr[i]的元素下标。轻松算出答案。

还有一个问题，如果有重复元素怎么办。

我们用单调栈维护前面第一个比arr[i]大或者相等的元素的下标，而后面维护严格大于arr[i]的元素的下标。这样一来答案就不会重复了。比如arr[l]==arr[j],本来会重复计算区间是[l,r],现在这个区间只会背arr[r]计算。

最后还有一个问题是求逆元。用费马小定理+快速幂可以logn，用exgcd也可以logn

# j
马老师这个题我们观察一下，比如1 2 3 4 5 6 7 7 7，每种菜出现次数是1 1 1 1 1 1 3，显然是贪心的取个数多的菜更好。如果选 1 2 3和4 5 6的话，只能做两个菜，但是答案应该为3。用优先队列，每次取出剩余最多的三个菜，把他们做成一道菜，再把剩下的菜放回去，最终剩余的菜的种类小于3种了就停止。时间复杂度nlogn

# k
这题一个n*m的矩阵，有矩形区间加法和询问矩形的和。显然要使用二维树状数组。但是我选择线段树，4叉那种，把区间分成左上左下右上右下4份分别维护。结果一直tle。题解讲座的时候讲kdtree做法，感觉这个线段树有点像kdtree每次都取中间分，不过实际上完全不一样。四叉的线段树和树状数组的复杂度应该是一样的吧，但是我写的常数太大，根本跑不过。树状数组做法参照一维的区间加法和区间求和写。维护差分数组，然后修改就在差分数组上做，求区间和实际上就是求原数组的前缀和，也就是差分数组做两次前缀和，

a[i]=b[1]+...+b[i]

a[1]+...+a[i]=b[1]*i+b[2]\*(i-1)+...+b[i]\*1=sigma(n-i+1)\*b[i]

然后我们维护一个(n-i+1)\*b[i]的前缀和就行了

二维完全类似，只不过上面的b[i]=c[i][1]+...+c[i][j];我们推一下公式发现维护ic[i][j],jc[i][j],ijc[i][j],c[i][j]的前缀和就好了。

# l
树链剖分可以把树上一些问题(比如路径和子树的和之类的)变成区间问题，区间问题又可以方便的用线段树之类的维护，于是树链剖分是个好东西。我只会重链剖分。首先我们想把子树和两点间路径都搞到一个连续区间里。对一个树dfs，他的所有子树的节点肯定都在连续的区间内，这很好。如果是链的话可以把链分成段来做。这里就有了重链。一个父节点有一些儿子，对应的子树大小最大的那个儿子就叫重儿子，其他的叫轻儿子，沿着重儿子走的链就叫重链(重链的起点都是一个轻儿子，否则这样的重链可以向上延申)如果一个树。dfs的时候如果我们都先走重儿子，那么一条重链的dfs序就是连续的了。同时，我们把树上任意路径分为链的时候也有复杂度保证了，考虑根节点到任意一个叶子节点，因为重儿子总是最大的，所以对于任意的轻儿子，他的子树大小都是小于等于他的父亲节点的子树大小的二分之一，因此如果只走轻边的话走logn条边就可以到叶子节点，这说明任意两点之间的路径包含的链的条数是logn级别的。然后我们就可以像求lca一样来处理路径了，比如求u->v的路径上的信息，如果u,v在同一个链上，那么直接可以在线段树里求出答案，如果不在同一个链内，我们就把属于比较靠下的链的那个点向上跳，比如u所在的链的开始节点深度大，我们把答案加上u,u.top这个区间的值，然后再把u跳到t.top.father上去，就像求lca一样。这样由于上面的链数保证只有logn级别，线段树询问也是logn，单次询问就是(logn)^2，非常快。

# n
平衡树的板子，

# o
可持久化并查集

就是可以返回历史版本的并查集，显然我们可以对于每个版本建一个并查集，但是这样会mle，于是想到了用线段树的叶子节点来存fa数组，用可持久化线段树来维护历史版本，这样每次更新如果只改变一个节点的话我们只需要新建logn个节点。并查集如果用路径压缩，一次查找可能要改变很多个节点，这样没法可持久化（仍然会mle）于是就想让每次merge操作只能改变一个节点。于是路径压缩是用不了了，只能用启发式合并，于是我们就维护一下并查集的size，然后按大小合并，每次把消的集合合并到大的集合下面。这样虽然牺牲了空间和查找时间但是可以可持久化了。每次查找并查集最差logn，可持久化数组还需要logn.

这题数据实在是水啊，启发式合并完全是反的竟然过了，写题解的时候才发现合并操作写错了，更新节点大小的时候更新的小集合根节点的size...(写的时候想反了，以为可以只维护一个主席树...)

改了之后是这样
```cpp
int i;
const int N = 3e5+10;
const int sz=N<<5;
int ls[sz],rs[sz],rt[sz],fa[sz];
int lls[sz],rrs[sz],rrt[sz],siz[sz];
// pair<int,int> dst[sz];//first->father,second->sz
int arr[N],id[N];
int tot,m,n,siztot;
int build(int l,int r)//建树的时候完全一样
{
	int rt=++tot;
    siztot=tot;
	if(l==r)	{fa[rt]=l,siz[rt]=1;return rt;}
	int mid=l+r>>1;
	lls[rt]=ls[rt]=build(l,mid);
	rrs[rt]=rs[rt]=build(mid+1,r);
	return rt;
}
int addfather(int pre,int l,int r,int idx,int father)
{
	int rt=++tot;
	ls[rt]=ls[pre],rs[rt]=rs[pre];
	if(l==r){fa[rt]=father;return rt;}
	int mid=l+r>>1;
	if(idx>mid)//rson 
		rs[rt]=addfather(rs[pre],mid+1,r,idx,father);
	else ls[rt]=addfather(ls[pre],l,mid,idx,father);
	return rt;
}
int addsize(int pre,int l,int r,int idx,int SZ)
{
	int rt=++siztot;
	lls[rt]=lls[pre],rrs[rt]=rrs[pre];
	if(l==r){siz[rt]=SZ;return rt;}
	int mid=l+r>>1;
	if(idx>mid)//rson
		rrs[rt]=addsize(rrs[pre],mid+1,r,idx,SZ);
	else lls[rt]=addsize(lls[pre],l,mid,idx,SZ);
	return rt;
}
//return idx->fa
int query(int idx,int rt,int l,int r)
{
    int mid=l+r>>1;
    if(l==r)    return fa[rt];
    if(idx>mid) return query(idx,rs[rt],mid+1,r);
    else    return query(idx,ls[rt],l,mid);
}
int querysiz(int idx,int rt,int l,int r)
{
    int mid=l+r>>1;
    if(l==r)    return siz[rt];
    if(idx>mid) return querysiz(idx,rrs[rt],mid+1,r);
    else    return querysiz(idx,lls[rt],l,mid);
}
int _find(int x,int rt)
{
    while(query(x,rt,1,n)!=x)   x=query(x,rt,1,n);
    return  x;
}
void merge(int x,int y,int root)
{
    int fax=_find(x,root),fay=_find(y,root);
    if(fax==fay)    return;
    // int szx=dst[query(fax,root,1,n)].second,szy=dst[query(fay,root,1,n)].second;
    int szx=querysiz(fax,rrt[i],1,n),szy=querysiz(fay,rrt[i],1,n);
    if(szx<szy)
        rt[i]=addfather(rt[i],1,n,fax,fay),rrt[i]=addsize(rrt[i],1,n,fay,szx+szy);
    else
        rt[i]=addfather(rt[i],1,n,fay,fax),rrt[i]=addsize(rrt[i],1,n,fax,szx+szy);
}
```
# i
扫描线

把矩形都画在一个坐标系中，假设我们有一条平行于x轴的直线从y=0向着y=ymax扫，这条扫描线每次遇到矩形的边就会停下来。有点像差分的思想，每次遇到一个矩形的下边界，就说明有一个矩形从这里开始，把差分数组在这个位置+1，如果遇到一个矩形的上边界，说明这个矩形结束了，把差分数组对应的加上-1。这样对这个差分数组每行出现的非0元素个数求前缀和就能得知矩形面积的并（如果直接对差分数组的和求前缀和就是所有矩形面积之和而不是面积并了）。我们只需要得到最终答案，于是就不用记录整个差分数组，只需要记录扫描线某一次停下的状态，然后每次改变状态之后把答案加上这一行的 非零元素个数*区间高度 就行了。这样就变成了一堆区间加法和一堆区间和询问，就可以用线段树维护上面说的“差分数组”。x和y都可以到1e9，需要离散化才行。

然后再看这个题，要求偶数个矩形重叠的面积。上面说的方法可以轻松求出面积的并了，也就是总共的面积，但是求偶数个矩形覆盖的面积比较困难。于是就得用总共的面积减去奇数次覆盖的面积。奇数次覆盖的面积就比偶数次覆盖的好求。因为求总面积的时候遇到重叠的情况好处理，求奇数次覆盖的面积我们可以取反，就是如果要将这个地方设为1并且原来就是1，说明这个地方现在被覆盖了偶数次，就把这一位设为0，如果遇到矩形上边界要把某个位置设为0的时发现这个位置本来就是0，就要反转成1，这是因为每个矩形都是先遇到下边界在遇到上边界的，为0的时候遇到上边界说明肯定是从偶数次覆盖要变成奇数次覆盖，不可能是直接变成0次覆盖。但是偶数次覆盖不一样，这没办法处理0次覆盖。因为如果遇到上边界的时候某一位要更改但是恰好为0，无法确定是变成0次了还是变成偶数次，0次不应该统计答案但是偶数次需要统计。这就是要用面积并减去奇数次覆盖的原因。

写一下实现细节。

同时因为每次都要统计一次答案也就是说每个区间修改之后都要区间询问，写lazytag也没什么用，干脆不写。

然后注意x要离散化，线段树叶子节点表示的不是坐标，而是区间的编号，比如叶子节点[l,l]表示的就是x[l]--x[l+1]对应的区间。然后离散化之后一共有len个x，也就是len-1个区间，我们建树的时候叶子节点一共有len-1个。因为每个矩形都是先处理下边然后处理上边，这样就可以完全不用下传标记，比如遇到一个区间1，4的下边，表示区间1，4的节点的sum+=1，然后遇到1，2的下边，区间1，2的节点sum+=1，然后遇到1，2的上边，这时只需要区间1，2的节点sum-=1，完全不用管区间1，4那个节点。后来自然会有1，4的上边把他删掉。但是处理奇数覆盖的时候不能这样，插入1，4的边之后区间1，4对应的节点sumodd为1，然后插入区间1，2，这时区间1，2应该不计算答案了，显然不能用更新sum的方法来更新sumodd，每次区间更新的时候都要把所有节点（除了叶子节点）的sumodd标记下传给他们的儿子，他们的儿子的sumodd就要反转，然后其实不必从叶子节点向上计算lenodd的值，反转之后这个区间本来是奇数次的地方变成了偶数次覆盖，偶数次变成奇数次，只需要用区间总长度减去现在的lenodd就能得到反转之后的lenodd即可。


# v
这题没有修改，只有一堆查询区间最大值，就想到用st表非常合适。st表就是用倍增的预处理。st[i][j]记录一下从第i个元素开始往后2^j长度的区间里某个问题的答案，然后就要想一想这个st[i][j]要怎么求，按照人的本能就分成st[i][j-1]和st[i+2^(j-1)][j-1]两部分，比如求最大值，转移方程就是

st[i][j]=max(st[i][j-1],st[i+2^(j-1)][j-1]);

然后就是处理询问了，询问区间是[l,r]，我们找一下从l开始的最长的st[i][j]，那我们可以用k=log2(r-l+1)向下取整来搞，然后两个区间[l,l+2^k-1]和[r-2^k+1,k]来合并答案。也就是说每次只用找两个区间就行了，这样单次询问就是O1的了。预处理是nlogn。

上面求答案的时候显然有可能让两个区间重叠，所以这个st表只能求最大值最小值，gcd之类的问题，不能求区间和之类的问题。

# y
这个题，一个人有两个喜欢的玩具。他们排队拿玩具，他们都会拿走自己喜欢的玩具(1个或2个)，要是没拿到他就不高兴，问不高兴的人数最少是多少。

一个人有两个喜欢的玩具，可以用图来描述。每个人是一条边，玩具是点，一个人喜欢ab玩具就给ab之间连一条边。