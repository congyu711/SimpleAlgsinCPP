# a
一个有n个点的完全图，每个点有点权，边e(i,j)的长度为点i和j的点权的异或。求最小生成树的边权之和。n有2e5。因为是完全图，边是$n^2$级别的，就选择最常用的kruskal来做这道题！kruskal一般是$mlogm$的（因为边排序），如果不算排序就是$mα(m,n)$的，思考一下主要问题在哪里。首先时间复杂度里面不能带m，也就是说不能存边，然后根据kruskal的过程我们还需要按照边权从小到大来获取边。这就需要一种数据结构，存一些数，然后获取两两之间的异或值，这大概要用01trie。数据范围```a[i]<2^30```暗示了这一点。

然后思考一下按照异或值从小到大连边并且不能有环这个问题。01trie上某个深度为dep的节点的左子树里面的数dep位都是0，右子树都是1，那么左子树内部的点异或第dep位还是0，右子树也一样，如果是左右子树之间的数异或第dep位就是1了，肯定是左（右）子树内部的点的边权比跨子树的点的边权要小。这样如果在01trie上递归连边，先把左右子树都连一些边变成一个最小生成树，然后考虑左右子树之间的边，连接其中最小的那一条，这样连出来的边肯定不会重复（因为点所在的子树都不一样）完全不用并查集判断是否成环。于是就搞出来了一个完全不像kruskal的东西，在01trie上递归连边，每次先处理左右子树，然后一条边把左右子树连起来。完全不是图论题了。
我发现如果用01trie的话还要考虑有重复权值的节点，但是其实根本不用考虑，如果有一样权值的节点直接就合并了，权值一样的节点之间的边权是0，因为是完全图并且边权是异或值，根本不用考虑他到底是连向权值一样的节点中的哪一个。
# b
一个网格图，求最大流。
就直接用dinic求了，每次先把残量网络bfs分层，然后dfs找层数递增的增广路，然后更改流量，重复过程直到bfs跑不到汇点为止。残量网络里面正向边可以直接用容量-流量得到，反向边就是流量。然后有几个优化。如果现在在找增广路，当走到节点u的时候流量最大还可以是```flw```，然而走完u的某一条出边（比如```e1```）,发现走出去的流量小于走进u点的时候的流量，这说明这个点应该还可以找到其他增广路，可以把剩下的流量再利用一下，于是更新现在能利用的最大流量```flw```为```flw-tmp```，这里```tmp```是刚刚找到的增广路的流量。这样一来就可以一次找到很多增广路了。然后如果一条出边被走过了，显然不能再走了（因为如果再走这条边还能找到增广路，说明刚刚找到的增广路的流量根本不是最大的），于是标记一下每个点走到了第几条出边。炸点是判断所有出边都满流就改dep来让这个点在本次多路增广中跑不到，感觉写了这个每个出边只走一次就不用炸了。最后是建图，无向图反向边直接建成正向边一样的容量就行了，反向边就是为了能退流，无向图怎么走都行，于是最后残量网络中正向和反向边都有流量也无所谓，用一个变量记住每次增广路流量的和就是答案。
# c
给定一个无向连通图，图中有nn个节点和mm条边，每次操作可以使某条边的边权增加或降低1，问最少需要多少次操作可以使得图中某棵生成树的最大边权恰好等于给定值k。
首先大家都知道，最小生成树一定是最小瓶颈生成树，也就是说里面的最大边最小。这道题首先把最小生成树求出来，如果发现要求的k比最小生成树里的最大边权还要大，那么就取一个集合，里面有小于等于（最接近k的数）的所有边，因为最小生成树的边都在里面，那这个边集肯定能形成一个生成树，然后加入最大边，这个最大边也就是最接近k的边，这个边同时也一定是一个非树边，那我们拆掉一个最小生成树里面的边，就能在这个边集中找到一个新的生成树，于是答案就是最接近k的数与k的差值。
如果k比最小生成树里面的最大边权要小，那么如果不把所有大于k的边减小到等于k，是找不出来生成树的。答案就是生成树中所有大于k的边-k的和。
# g
一个n个点m条边的有向无环图，求每个点能到达的点的数量。手算一下样例，发现应该是按照拓扑排序的逆序来更新答案就行了。于是就先拓扑排序。拓扑排序之后就按照逆序来处理每一个点，对于节点i（为了方便叙述，让节点i可以到达的节点数量是dp[i]），$dp[i]=\sum dp[j]-rep\quad$ $j$是$i$的出边可以到达的节点。rep是重复计算的节点。这里又遇到了一个问题，重复的节点有点难算。那么就可以每个节点都搞一个bitset，节点i的bitset的第j位就记录节点i能不能走到节点j。dp数组就记录这个bitset，可达的点的数量就是bitset里面1的个数。每次更新的时候就是$dp[i]=dp[i]|dp[j]$
clar里说有重边，这样每次或一下根本不用管重边
# i
给一个有向图，每条边看成道路，路费可以用两种货币a或b支付，每个点有a和b的汇率，从s点出发去t点，出发时携带一些a货币，中途经过某个点u的时候可以按照u点的汇率将a货币换成b货币（最多一次），问出发时携带的最少a货币。
考虑从s到t的过程，首先从s到u，这一部分用a货币支付，然后从u到t，这一部分用b货币支付。容易发现这是两个最短路问题，以s点为源点，a为距离的单源最短路和以t点为源点，b为距离的单源最短路，于是可以建两个图，跑两次dijkstra，然后找里面 ```disa+disb/r```最小的值，然后这个题还带一些修改，修改第i个点的汇率，那这是单点修改然后询问最大值，用线段树维护一下即可。
# j
给2n个点，这2n个点已经被两两一组分成了n个点对。然后给m个询问。每个询问也包括两个点。从前向后遍历每个询问，对于每个询问当中的两个点，选择一个点，然后删除包含这个点的点对，无点可选就结束，问最多可以执行几组询问。
这是2-sat问题，对于每个点对，只有一个可以选择，也就是说他们两个是互斥的。如果现在处理到第i个任务，两个球分别是```c[i]```和```d[i]```，选择了```c[i]```互斥的点对意味着没有选择```c[i]```，那就只能选择```d[i]```了。反之亦然。用有向图来描述这个关系。第i个任务涉及到的球是```c[i]```和```d[i]```，添加两条有向边，分别是```f[c[i]]->d[i]```和```f[d[i]]->c[i]```。建完图之后，如果发现有```f[i]```和```i```在同一个scc中，就说明既可以选择i也可以选择f[i]，这与题意不符，因此这就说明建的图不合法，也就是说答案不能执行这么多任务。二分答案，然后每次都重新建图，找强连通分量，然后判断答案是否合法。
# l
给一个二分图，求最大匹配然后判断最大匹配的边数是否等于二分图左部的点数。直接用增广路算法找最大匹配就行了，如果用b题那个dinic左部建个超级源点，右部建个超级汇点还可以快很多。
# m
https://yhx-12243.github.io/OI-transit/records/uoj79.html

# p
求割点割边极大点双连通分量数量和极大点双连通分量里面边数最大值。
首先这些东西都是在dfs生成树上求的。dfs生成树就是dfs首先连上的边是树边，dfs的时候已经在树里的边就分情况，分成返祖边，横插边等，反正都是非树边。
1. 看某个点u是否是割点。直接看这个点的子树里面有没有点有非树边能连接到比u更靠上的点。那么想一个办法来表示哪个点更考上，于是就有了dfs时间戳。dfs的时候访问某个点的时候就记录一下时间戳。然后还要想办法记录这个点通过他的非树边和他子树里面节点的非树边能到达的最上面的节点，这个可以在dfs的时候计算出来，low[u]=min(low[u],low[v]);（如果v是u的儿子），low[u]=min(low[u],pre[v]);（如果v不是u的儿子，是非树边连接的点）。
然后如果low[v]>=pre[u]，就能说明这个点的儿子不能连接到比他更靠上的节点了，这个节点就是割点了（要特判一下树根，如果树根那部分是链的话树根不算是割点）
2. 割边。如果一个节点的儿子的low值比u要大，就是说这个儿子不能通过他的子树到达比他的父亲更向上的点，那么从父亲到儿子这条边就是割边了，这倒没有特殊情况。
3. 点双联通分量。观察发现点双连通分量最多只有一个公共点，这时不同的点双连通分量被割点分开了。考虑树边和非树边，如果有一条非树边u-v，那么肯定存在u-v的树上路径。那么u-v的树上路径加上这个非树边构成的子图就是一个点双连通分量。于是开一个栈来存边，然后遇到一条边的时候先把他入栈，然后找到割点了，说明要有一个新的点双连通分量了，那就把边一个一个出栈，直到遇到u-v的非树边。这样一个点双联通分量就找到了。
4. 边数可以在3中顺便求得。


# r
这道题问的是树上到两点距离相等的点的个数，有多组询问。首先画图看看都有什么情况；
1. 如果a b 是同一个点，那答案等于n
2. 如果a b 到根的深度一样，那就是说如果a和b的lca是c的话，a到c和b到c距离一样，那么只有lca的有a的这个子树和lca的有b这个子树里面的点到ab的距离不相等，那么答案就是 ```n-sz[subtree(lca=>a)]-sz[subtree(lca=>b)]```
3. 如果a b 深度还不一样，那假设a和b的中深度比较深的是a，并且ab距离是dis，如果dis是奇数，那么不可能有点到ab的距离相等，如果是偶数，那么到ab距离相等的点就是a向上跳dis/2之后的那个点和那个点不包括a的那个子树。也就是```sz[fa[a][dis/2]]-sz[fa[a][dis/2-1]]]```

因此发现只要维护一个每个点的深度，然后倍增lca就行了。