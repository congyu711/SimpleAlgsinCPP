# b
有n个点，编号1-n，从i到j路径长度Dij，两个人从1号节点出发，只能从编号小的点走到编号大的点，要经过所有节点，求最短路径长。 n<=2000
想到两个人从节点1出发经过所有节点有些麻烦，可以看成一个人经过了所有节点。两个人中一定要有一个人去节点n，可以看成这个人反向走路，从节点n按照他的路径返回节点1，然后再走剩余的节点。这里这个人显然可以重复经过某个节点。因为可能存在这样一种情况，有三个节点，编号分别为1、2、3，
```dis[1][2]=1 dis[2][3]=1 dis[1][3]=1000```
这样假设节点2已经经过了，现在要从节点1出发前往节点3，这里显然是从节点1先到节点2再到节点3更短。

然后思考一下状态转移方程。因为n<=2000，显然转移的复杂度是$O(n^2)$。直接令```dp[i][j]```为从i这个节点向左走到1这个节点然后再向右走到j这个节点的最短路径长（即满足上文叙述的一个人的走法的最短路径），很显然正着走和反着走都一样，所以```dp[i][j]```显然等于```dp[j][i]```，于是不妨令```i>=j```，（```i<=j```的情况相当于i和j互换），然后可以思考一下转移方程了。
1. ```j<i-1```：这样的话i-1这个点只能由i向左走的时候访问到，因此$$dp[i][j]=dp[i-1][j]$$
2. ```j>i-1```，也就是```j==i-1```和```j==i```，这样一来需要枚举一下i向左走的第一步$$dp[i][j]=min(dp[k][j]+dis[i][k]) \qquad k∈[1,i-1]$$

对于每一个i，情况2会出现2次，情况1会出现i-2次，情况1的转移是$O(1)$,情况2的转移是$O(n)$，因此时间复杂度为$O(n^2)$
# c
题意：求序列所有不同的非下降子序列的个元素的乘积的和。
很容易产生从前到后一个一个处理元素的贡献的冲动。。。于是就这么做。（先不考虑重复的元素）第i个元素对于以前的非下降子序列的贡献就是他前面所有比他小的元素的贡献之和*这个元素的值（因为在他前面并且比它小的都可以直接在后面加上他），第i个元素还可以自己成为一个非下降子序列的第一个元素，于是贡献再加上他自己的值。于是在没有元素重复的情况下很容易得到状态转移方程。$$dp[a[i]]+=(\sum_{j=1}^{a[i]}dp[j])*a[i]+a[i]$$
这样一来发现这里```dp[a[i]]```是单点更新，而且更新的时候要求一个区间和，就可以用树状数组来维护这个dp数组。于是复杂度变成$O(n*log(maxa[i]))$。可以过了。

最后要考虑一下重复的序列。可以轻易发现每次状态转移的时候多算的贡献就是前面所有和a[i]相同的数的贡献，把他减掉就行了。

这题写树状数组的时候搞错了n。。。dp数组的下标是元素的值，边界应该是a[i]的最大值。写的时候边界直接当成n了，改了好久。。。

# e

用dp[i][0]表示现在处理到第i个数了，0表示这个数不拆，dp[i][1]表示这个数拆。

考虑状态转移方程，如果第i个数不拆，那么他对结果毫无影响，所以dp[i][0]=dp[i-1][0]+dp[i-1][1],
如果第i个数要拆开，那么考虑第i-1个数拆不拆，如果第i-1个数拆，（现在假设第i-1个数是k，第i个数是m）那他只能拆成第k个到第m-1个斐波那契数.如果第i-1个数不拆，那他只能拆成第k+1个到第m-1个斐波那契数。

现在考虑第i个数拆成第k个到第m-1个斐波那契数有多少种方案。fib[i]=fib[i-1]+fib[i-2]，然后发现如果拆了fib[i-1]，一定会拆出来fib[i-2]和fib[i-3]，fib[i-2]就重复了，然后又要拆掉一个fib[i-2]，但是这又会产生fib[i-3]重复，所以拆掉fib[i-1]的数一定会产生重复，只能拆fib[i-2]。于是m-k至少为2才有一种，m-k每增加2就能多拆一次。所以答案为(m-k)/2
因此转移方程就是```dp[i][1]=dp[i-1][0]*((vec[i]-vec[i-1]-1)/2)+dp[i-1][1]*((vec[i]-vec[i-1])/2);```
# f
求满足条件的数列个数
- ```a[1]=a[0]=1```
- ```0<=a[i]<=2```
- 相邻数的差不超过1
- 有一些限制条件，给出 l，r，k，在区间```[l,r]```中不能有```a[i]=k```


首先不考虑最后一个条件，那么第i个元素可以填0，1，2，填0的方案=上一个数填0和1的方案数之和，填1的相当于上一个数填0 1 2的方案数之和，填2的相当于上一个数填1 2的方案数之和。很容易得到转移方程。设$dp[i][k]$为第i个数填k的方案数，转移方程为
$$\begin{align}
&dp[i][0] = dp[i-1][0]+dp[i-1][1]\\
&dp[i][1] = dp[i-1][0]+dp[i-1][1]+dp[i-1][2]\\
&dp[i][2] = \quad \qquad \qquad+dp[i-1][1]+dp[i-1][2]\\
\end{align}$$
发现这个递推公式非常简单，可以写成矩阵形式。
$$
 \left[
 \begin{matrix}
   1 & 1 & 0 \\
   1 & 1 & 1 \\
   0 & 1 & 1
  \end{matrix}
  \right]^k \tag{3}
$$
于是可以使用快速幂优化。

现在来考虑第四个条件。如果在某个区间内a[i]不能取k，那么相当于上面的矩阵第k行全为0。于是就可以分段进行处理，然后分别进行快速幂。

分段有点困难、、、、、、这个题和扫描线不同，扫描线求矩形面积并的时候如果某两条线段端点是同一个点，比如产生了[3,3]这种区间，他必然对答案不产生贡献，所以直接不用管，可以对横坐标直接去重离散化，区间的个数就是离散化之后点的个数-1。但是这个题如果因为某些原因出现了[3,3]这种只有一个点的区间，显然就不能直接扔掉。。。离散化的时候如果不去重的话又会产生很多问题。比如n=5，约束条件是第二个数不能填0.那么不去重就得到（2 2 2 4）离散化之后（1 1 1 2），这样根本不能用。我想把区间都处理成开集，然后单独看点，这样就是，点的集合有2，4，区间的集合有(2,4)。逐个约束条件处理，维护点和区间的集合不能用的数。这样因为数据只有1e4，直接每个约束暴力维护点和区间的集合就行了。
# g

分组背包。

这道题每个装备有4个强化等级，但是还可以不强化，也就是可以不选。

```dp[i][j]```表示前i组物品花费j容量能达到的最大价值。（每组物品最多只能选一个）这里就需要思考一下物品组，背包容量，每组物品三个变量的枚举顺序。首先肯定要枚举物品组，然后如果先枚举每组中的物品再枚举背包容量的话，同一组中排在后面的物品很可能进行转移的时候是在已经插入了同组排在前面的物品的基础上转移过来的，这显然不符合每组最多选择一个物品的题意；如果是先枚举背包容量再枚举同组物品的话，因为背包容量是倒序枚举的，那么对于每一个背包容量v，他只能被```dp[v-c[i]]+w[i]```更新，然而比v小的容量还没有处理到，必然不可能已经插入了同组其他物品，这就保证了同组最多选择一个物品。转移方程很容易想到：
$$dp[v]=max(dp[v],dp[v-c[i]]+w[i])$$
枚举顺序是先枚举物品组，再倒序枚举容量，最后是同组中的物品。
# k
必须选第1个数的最长非降子序列。
首先如果不一定要选第一个数，那么这就是板子了，```dp[len]```表示长度为len的最长非下降子序列的末尾元素现在是多少。那我们每次处理一个新元素。我们发现，一个长度为len的非下降子序列末尾元素肯定小于等于长度大于len的非下降子序列末尾元素，也就是说dp数组是有序的，那每次处理到一个新的数的时候，可以二分查找末尾元素大于这个元素的第一个位置```i```，然后把```dp[i]```换成```arr[i]```。如果他甚至比目前最长的最长非下降子序列还要长，那肯定要延长最长的最长上升子序列，也就是让```dp[++len]=arr[i]```。这样一来可以在$O(nlogn)$的时间内求出答案。
然后考虑这个题的特殊条件。必须选第一个数。那么在处理后面的数的时候发现他小于第一个数就直接跳过即可。
# l
这道题给两个数组，可以往其中插入任意多空格。然后问上下对齐的位置的相等元素最多有多少。这显然是求这两个序列的最长公共子序列。求最长公共子序列又是板子啦。让```dp[i][j]```表示第一个序列前i个元素和第二个序列前j个元素的最长公共子序列的长度。考虑转移方程

$$dp[i][j] = \begin{cases}  
0 & arr1[i]==arr2[j] \\
\max\{ dp[i-1][j],dp[i][j-1] \} & arr1[i]!=arr2[j]
\end{cases}$$

# m
有依赖的背包问题。依赖关系组成了一棵树，要求保留根节点情况下的最大价值。而且价值有负数。

我们先考虑保留根节点这个问题，如果根节点是负的，而且如何选取他的子树都会导致最终答案小于0，那么说明这个根节点也不应该选，但是题目强制要求选取根节点，我们可以直接把根节点加上1e9+7，把他变成正的，这样无论如何都会选择根节点。最终答案减去1e9+7即可。

然后考虑这是一个树形dp，dp[i][j]表示以i为根节点，以j为背包容量的最大价值。那么我们来仔细思考一下转移方程。假设i节点有n个儿子，现在要求dp[i][j]，他就等于```max(给i节点的n个儿子分配容量（j-1）（可以有剩余）的最大值加上i这个节点的权值，0)```这里是j-1因为如果要选取i节点的儿子的话必须选择i节点（满足依赖关系）。实际上每个子树都是一个分组背包问题，只不过组数很多，但是我们不需要记住这些方案到底是什么，只需要知道再i的某个儿子s里面取容量为cap的最大价值是多少。发现这个数组实际上就是对s做01背包的结果。那dp过程就是对从叶子到根的所有节点的子树做01背包。这里有一个问题。要选一个节点的子树里面的节点就必须选择他自己。因此处理到节点i的时候不能直接i和叶子放到一起做dp，必须保证一直选上节点i。
```cpp
void dfs(int h,int cap)
{
    dp[h][1]=v[h];
    dp[h][0]=0;
    for(auto e:adj[h])
    {
        dfs(e,max(0,cap-1));
        for(int w=cap;w>=1;w--)
            for(int k=0;k<w;k++)
                dp[h][w]=max(dp[h][w],dp[h][w-k]+dp[e][k]);
    }
}
```
上面的代码中，注意枚举w的时候要大于等于1，因为做01背包的部分是节点h的所有子树，不包括h本身，因为h自己算入答案了才能选取他的子节点。枚举k的时候不能等于w，因为如果等于w的话转移方程相当于可能使用dp[h][0]来更新了，不符合依赖关系。这里```dp[e][k]```就相当于01背包里面的v[i]。

因为节点权值有负数，所以需要把dp初始值设为大负数

# n
这是一个换根dp。给一棵树，标记某些点（标记可能重复），求一个到所有标记的点的距离和最短的点。假设现在已经求出了节点i到所有被标记的点的路径和，那么现在要转移到根节点的子节点u，很显然以u为根的子树里面所有标记的点到u的距离比他们到节点i的距离小1，所以距离和要减少以u为根的子树里面所有标记的点的数量，然后对于所有不在以u为根的子树里面的被标记的点，他们到u的距离都比到i的距离大1，那答案需要再加上m-u为根的子树里面所有标记的点的数量(m为被标记的节点数目).所以得到了状态转移方程：
$$dp[u]=dp[i]-cnt[u]*2+m$$
这里```cnt[u]```表示以u为根的子树中被标记的点的数目，```dp[i]表示所有标记的节点到i节点的距离和```

然后我们需要预处理```cnt[u]```,还要计算一下```dp[root]```

这道题需要注意的是要输出编号最小的答案。这里就需要把所有距离和最小的答案记录一下，最后输出最小的。。。。。。因为这个WA了几次

# o 
给一两个很大的数，求[l,r]这个区间中的数有多少满足数字中有连续的42或者135.
42或135出现都可以，不好处理，求没有42和135出现的数的个数然后用数的总数减掉他得到答案。
这是数位dp。数位dp就是用按位枚举的暴力加上记忆化搜索的优化。首先如果直接暴力按位枚举的话肯定过于慢了。看看其中有哪些不需要算的东西。如果现在枚举到第i位，第i位的数枚举成j了，那么如果j根本不是4，j和j后面的数肯定无法组成42，j只要不是4都可以归为一种情况。135同理。如果遇到了这样的情况就可以把答案存下来，因为以后遇到再次计算就重复了。但是如果j的枚举有范围，只能从0到k，不能到9，我们把他存下来也可能有用，但是复用的次数比较少，而且需要额外把dp数组开一维来存k，不是很划算，因此只有j能枚举0到9的时候才存下来。

因为这种计数问题满足区间可加，因此直接算【1，r】的答案-【1.l-1】的答案即可。由于这个数字非常大，读入之后肯定是用string存。这个$l-1$就有点麻烦，可以直接算[1,l]的答案，最后特判一下l这个数满不满足条件。

还有计算两个数的差的时候，反正最后要取模，可以直接把两个大数先取模再减（还有要注意c++负数取模还是负的）
```cpp
LL dfs(int pos,int pre1,int pre2,int sta,int sta2,int sta3,bool lim)
{
    if(pos==-1) return 1;
    if(!lim && dp[pos][sta][sta2][sta3]!=-1) return dp[pos][sta][sta2][sta3];
    int up=lim ? (c[pos]-'0') : 9;
    LL res=0;
    for(int i=0;i<=up;i++)
    {
        if(pre1==4 && i==2)continue;
        if(pre2==1&&pre1==3&&i==5) continue;
        res+=dfs(pos-1,i,pre1,i==4,i==1,i==3&&pre1==1,lim && i==(c[pos]-'0'));
        res%=mod;
    }
    if(!lim) dp[pos][sta][sta2][sta3]=res%mod;
    return res%mod;
}
```
# w
丑序列的数量比较难求，我们直接求不丑的，然后用```1<<n```来减去它得到答案。

于是考虑不丑的序列的个数，只有下面四种情况（x为现在增加的一位）
1. ```00X```这个x只能选择1
2. ```01X```这个x可以选1和0
3. ```10X```这个x可以选1和0
4. ```11X```这个x只能选择0

于是实际上情况1，4的答案就是i-2的不丑的序列的个数，情况2，3的答案就是i-1的不丑的序列的个数*2（因为0和1都能取）

于是dp[i]表示1-i中不丑的序列的个数。转移方程：
```dp[i]=dp[i-2]*2+dp[i-1]```

答案为```(1<<n)-dp[n]```

 显然我们能发现这个n=1e4答案超大，要写高精度或者写python、、、


# r
先考虑01背包装满包的方案数怎么求。转移方程显然是```dp[j]=dp[j]+dp[j-w[i]]```

然后发现题目要问去掉一个物品的装满容量x的背包的方案数。假设现在我已经把01背包装满容量为j的包的dp数组全算完了，然后如果要去掉第i个物品，只需要做```dp[j]-=dp[j-w[i]]```，那我们对i从n到1做一遍上面的方程自然就可以得到不要第i个物品的dp数组了。(这个对于i做完之后需要复原dp数组，然后再算下一个i)

然后这个题需要注意的有以下几点
1. 枚举顺序。在做```dp[j]-=dp[j-w[i]]```的时候，我们要从n->1枚举i，此时需要从w[i]->m枚举j。
2. 题目要求一共nm个询问，也就是说不需要计算空包的答案...
3. c++负数取模是负数...


# s
 $$\sum_{i=1}^{inf} (1-p)^{i-1}*p*i=\frac{1}{p}$$
现在假设前i-1位的期望是$EX_{i-1}$，那么上式变成
 $$\sum_{i=1}^{inf} (1-p)^{i-1}*p*(i+EX_{i-1})=(1+EX_{i-1})*\frac{1}{p}$$

 这就是状态转移方程，最后将分母求mod 1e9+7的逆元即可。

# i
有n个学生m个任务，每个学生有一个焦虑度a[i]，现在要把m个任务全部分配个学生。要最小化$\sum_{i=1}^{n} a[i]*t[i]$，其中$t[i]$表示任务比他多的人的数量。
首先最优分配满足这样一个性质：如果按照a[i]排序，a[i]更大的学生分配的任务数肯定不少于a[i]更小的学生的任务数。这很容易证明：假设已经有了最有排列的分配情况，但是不知道哪个学生分配多少任务，只知道任务怎么分成n份，那么根据排序不等式，显然是让a[i]更大的人的t[i]更小才能让乘积和最小，也就是要让t[i]和a[i]倒序相乘，那么a[i]大的人要分配的任务就多。因此a[i]越大分配的任务就越多，至少不会比a[i]更小的少。
这里状态转移方程的设计有点困难（我看了讲座ppt才知道，原来根本没想出），令```dp[i][j]```表示前i个人（已经按照a[i]从大到小排序了）分配j个任务的最小代价。首先这个题任务数量没有用，相对任务数量才有用。如果前i个人里面没有人只有一个任务，那把每个人的任务都减去1答案显然不变（因为a[i]是固定的，t[i]只与相对任务数量有关），如果有一些人只有一个任务，根据上面讲的单调性，他们肯定都在按a[i]排列的末尾，假设有k个人只有一个任务。那么有i-k个人多于一个任务，现在把这些人的任务数量都-1，还是不改变相对任务数量，但是最后k个人就没有任务了，相当于还没有分配到这k个人，只处理到第i-k个人，而且不再有人只有一个任务，成功转移到第一种情况了。答案有一点区别，一位内最后k个人本来有$$\sum_{c=i-k+1}^{i} a[c]*(i-k) \qquad (1)$$的贡献，但是把后k个人的任务-1之后没有计算上。我们现在把他算上，发现就是a[i]的一个区间和乘以(i-k)，那我们预处理一个区间和，这个转移也是O(1).
然后就可以写了，首先枚举i，j，k，递推计算dp数组，答案即为dp[n][m];